library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
g <- ggplot(movies, aes(votes, rating))
print(g)
qplot(votes, rating, data = movies)
qplot(votes, rating, data = movies, smooth = "loess")
qplot(votes, rating, data = movies) + geom_smooth()
qplot(votes, rating, data = movies) + stats_smooth("loess")
qplot(votes, rating, data = movies, panel = panel.loess)
airquality = transform(airquality, Month = factor(Month))
qplot(Wind, Ozone, data = airquality, facets = . ~ Month)
qplot(Wind, Ozone, data = airquality, facets = . ~ factor(Month))
03_Getting_Data_Project
detach("package:datasets", unload=TRUE)
detach("package:graphics", unload=TRUE)
detach("package:grDevices", unload=TRUE)
detach("package:methods", unload=TRUE)
detach("package:stats", unload=TRUE)
detach("package:utils", unload=TRUE)
source("03_1_Import_Files.R")
myWD <- "~/Documents/Coursera/03-Getting_and_Cleaning_Data/Projects"
library("utils", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
myWD <- "~/Documents/Coursera/03-Getting_and_Cleaning_Data/Projects"
install.packages(c("boot", "class", "cluster", "codetools", "jsonlite", "KernSmooth", "MASS", "mgcv", "nlme"))
str(data[1:5; 1:3])  #  list out a few rows and all columns
str(data[1:5, 1:3])  #  list out a few rows and all columns
str(data[, 1:3])  #  list out a few rows and all columns
myWD <- ("~/Documents/Coursera/05-ReproducableResearch/05_RepData_PeerAssessment1")
setwd(myWD)
if (!file.exists('activity.zip')) {  # this will be in place if you fork the repo
file_URL <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
download.file(file_URL, "./activity.zip", method = "curl" )
}
unzip("./activity.zip", overwrite = TRUE)
pulldate <- date()
rm(pulldate)
if (!file.exists('activity.zip')) {  # this will be in place if you fork the repo
file_URL <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
download.file(file_URL, "./activity.zip", method = "curl" )
pulldate <- date()
}
if (!file.exists('activity.zip')) {  # this will be in place if you fork the repo
file_URL <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
download.file(file_URL, "./activity.zip", method = "curl" )
pulldate <- date()
} else {
unzip("./activity.zip", overwrite = TRUE)
unzipdate <- date()
}
data <- read.csv("./activity.csv")
str(data[, 1:3])  #  list out a few rows and all columns
library(kernlab)
install.packages("kernlab")
library(kernlab)
data(spam)
str(spam[,1:5])
str(spam[,])
set.seed(3435)
trainIndicator = rbinom(4601, size =1 , prob = 0.5)
table(traindIndicator)
table(trainIndicator)
trainSpam <- spam[trainIndicator == 1,]
testSpam <- spam[trainIndicator == 0,]
table(trainSpam$type)
plot(log10(trainSpam$capitalAve +1) ~ trainSpam$type) # ad one because so many zeros
plot(log10(trainSpam[,1:4]+1))
hCluster <- hclust(dist(t(trainSpam[,1:57])))
plot(hCluster)
hClusterLog <- hclust(dist(t(log10(trainSpam[1:55] + 1))))
plot(hCLusterLog)
plot(hClusterLog)
trainSpam$numType = as.numeric(trainSpam$type) - 1
View(trainSpam)
costFunction <- function(x,y) sum(x != (y> 0.5))
cvError <- rep(NA,50)
library(boot)
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType") # create formula
glmFit <- glm(lmFormula, family = "binomial, data = "trainSpam) # fit the model
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType") # create formula
glmFit <- glm(lmFormula, family = "binomial", data = "trainSpam") # fit the model
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
}
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType") # create formula
glmFit <- glm(lmFormula, family = "binomial", data = "trainSpam") # fit the model
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType") # create formula
}
for (i in 1:55) {
glmFit <- glm(lmFormula, family = "binomial", data = "trainSpam") # fit the model
}
class(trainSpam$capitalAve)
for (i in 1:57) {cl <- class(trainSpam[,i]) print(cl)}
for (i in 1:57) {cl <- class(trainSpam[,i]); print(cl)}
for (i in 1:59) {cl <- class(trainSpam[,i]); print(cl)}
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType") # create formula
glmFit <- glm(lmFormula, family = "binomial", data = "trainSpam")    # fit the model
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
cvError <- rep(NA,55)
lmFormula <- reformulate(names(trainSpam)[1], response = "numType") # create formula
lmFormula <- reformulate(names(trainSpam)[1], response = "numType") # create formula
lmFormula <- reformulate(names(trainSpam)[2], response = "numType") # create formula
lmFormula
class(lmFormula)
glmFit <- glm(lmFormula, family = "binomial", data = "trainSpam")    # fit the model
glmFit <- glm(lmFormula, family = binomial, data = "trainSpam")    # fit the model
glmFit <- glm(lmFormula, family = binomial, data = trainSpam)    # fit the model
glmFit <- glm(lmFormula, family = "binomial", data = trainSpam)    # fit the model
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[2], response = "numType") # create formula
glmFit <- glm(lmFormula, family = "binomial", data = trainSpam)    # fit the model
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
names(trainSpam)[which.min(cv.Error)]
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType") # create formula
glmFit <- glm(lmFormula, family = "binomial", data = trainSpam)    # fit the model
cvError[i] = cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
warnings()
names(trainSpam)[which.min(cv.Error)]
names(trainSpam)[which.min(cvError)]
predictionModel <- glm(numType ~ charDollar, family = "binomial", data = trainSpam)
str(predictionModel)
predictionTest <- predict(predictionModel, testSpam)
predictedSpam <- rep("nonspam", dim(testSpam)[1])
tail(predictedSpam)
tail(predictedSpam, 20)
predictedSpam[predictionModel$fitted > 0.5] = "spam"
tail(predictedSpam, 20)
table(predictedSpam, testSpam$type)
errorRate <- testResults[2,1] + testResults[1,2]
testResults <- table(predictedSpam, testSpam$type)
errorRate <- testResults[2,1] + testResults[1,2]
errorRate <- testResults[2,1] + testResults[1,2]/dim(testSpam)[1]
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
predictedSpam[predictionModel$fitted > 0.6] = "spam"
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
testResutls
testResults
predictedSpam <- rep("nonspam", dim(testSpam)[1]) # prep vector for length of testSpam
predictedSpam[predictionModel$fitted > 0.6] = "spam"
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
predictedSpam <- rep("nonspam", dim(testSpam)[1]) # prep vector for length of testSpam
predictedSpam[predictionModel$fitted > 0.55] = "spam"
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
predictedSpam <- rep("nonspam", dim(testSpam)[1]) # prep vector for length of testSpam
# Classify as 'spam' for those with prob > 0.5
predictedSpam[predictionModel$fitted > 0.51] = "spam"
# Compare prediction to actual
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
predictedSpam <- rep("nonspam", dim(testSpam)[1]) # prep vector for length of testSpam
# Classify as 'spam' for those with prob > 0.5
predictedSpam[predictionModel$fitted > 0.52] = "spam"
# Compare prediction to actual
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
predictedSpam <- rep("nonspam", dim(testSpam)[1]) # prep vector for length of testSpam
# Classify as 'spam' for those with prob > 0.5
predictedSpam[predictionModel$fitted > 0.50] = "spam"
# Compare prediction to actual
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
predictedSpam <- rep("nonspam", dim(testSpam)[1]) # prep vector for length of testSpam
# Classify as 'spam' for those with prob > 0.5
predictedSpam[predictionModel$fitted > 0.49] = "spam"
# Compare prediction to actual
testResults <- table(predictedSpam, testSpam$type)
errorRate <- (testResults[2,1] + testResults[1,2])/dim(testSpam)[1]
max(trainSpam$charDollar)
mean(trainSpam$charDollar)
Here's an unordered list:'
mywd <-"~/Documents/Coursera/05-ReproducableResearch/05_RepData_PeerAssessment1"
if (!file.exists('/activity.zip')) {  # this will be in place if you fork the repo
file_URL <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
download.file(file_URL, "./activity.zip", method = "curl" )
}
download_date <- date()
unzip_date <- date()
raw <- read.csv("./activity.csv")
summary(raw)
class(raw$date)
class(raw$interval)
head(raw)[c(1,2,10,20,50,288)]
head(raw)[c(1,2,10,20,50,288),]
head(raw,[c(1,2,10,20,50,288),])
raw[c(1,2,10,20,50,288),]
raw[c(1,2,10,13,22,277,288),]
class(raw$interval) <- "character"
class(raw$interval)
raw[c(1,2,10,13,22,277,288),]
raw[c(1,2,10,13,14,22,277,288),]
substr("abcdef",2,4)
substr("abcdef",2,2)
interval2time <- function(val) {
if (length(val) < 2) {
val <- paste0("00:0",val) }
else if (length(val) < 3) {
val <- paste0("00:", val) }
else if (length(val) < 4) {
val <- paste0("0", substr(val,1,1),":",substr(val,2,3)) }
else {val <- paste0(substr(val,1,2),";",substr(val,3,4)) }
}
interval2time(2355)
V <- interval2time(2355)
V <- interval2time("2355")
length("2355")
nchar("2355")
nchar("235")
interval2time <- function(val) {
if (nchar(val) < 2) {
val <- paste0("00:0",val) }
else if (nchar(val) < 3) {
val <- paste0("00:", val) }
else if (nchar(val) < 4) {
val <- paste0("0", substr(val,1,1),":",substr(val,2,3)) }
else {val <- paste0(substr(val,1,2),":",substr(val,3,4)) }
}
V <- interval2time("2355")
V <- interval2time("955")
V <- interval2time("55")
V <- interval2time("155")
setwd(mywd)
library(lubridate)
raw <- read.csv("./activity.csv")
class(raw$interval)
class(raw$interval) <- "character"
interval2time <- function(val) {
if (nchar(val) < 2) { # for hour 0
val <- paste0("00:0",val) }
else if (nchar(val) < 3) {  # for hour 0  and minutes > 5
val <- paste0("00:", val) }
else if (nchar(val) < 4) { # for hours 1 to 9
val <- paste0("0", substr(val,1,1),":",substr(val,2,3)) }
else {val <- paste0(substr(val,1,2),":",substr(val,3,4)) }  # for hours 10 to 23
}
raw$DateTime <- ymd_hm(paste(date, interval2time))
raw$time <- sapply(raw$interval,interval2time)
View(raw)
raw$DateTime <- ymd_hm(paste(date, time))
raw$datetime <- paste(date, time)
class(raw$date)
class(raw$date) <- "character"
raw$datetime <- paste(date, time)
class(raw$date) <- "character"
class(raw$date)
paste(date, time)
paste(date, time)
paste("1", time)
paste(raw$date, raw$time)
View(raw)
raw <- read.csv("./activity.csv", stringsAsFactors = FALSE)
class(raw$date)
View(raw)
summary(raw)
paste(raw$date, raw$time)
class(raw$interval) <- "character"
raw$time <- sapply(raw$interval,interval2time)
paste(raw$date, raw$time)
charDT <- (raw$date, raw$time)}
charDT <- (raw$date, raw$time)
charDT <- paste(raw$date, raw$time)
DateTime <- ymd_hm(charDT)
DateTime
head(DateTime)
head(charDT)
data <- cbind(raw$steps, DateTime)
View(data)
rm data
remove(data)
data <- cbind(raw, DateTime)
View(data)
###What is mean total number of steps taken per day?
aggregate(data, by = date, FUN = Mean)
aggregate(data, by = date, FUN = sum)
aggregate(x = date, data = data, FUN = sum)
aggregate(steps ~ date, data = data, FUN = sum)
stepsPerDay <- aggregate(steps ~ date, data = data, FUN = sum)
hist(stepsPerDay)
hist(stepsPerDay$steps)
hist(stepsPerDay$steps, breaks = stepsPerDay$date)
plot(y = stepsPerDay$steps, x = stepsPerDay$date, type = "h")
plot(y = stepsPerDay$steps, x = stepsPerDay$date, type = "l")
plot(stepsPerDay)
plot(stepsPerDay$date,stepsPerDay$steps, type = "h")
library(ggplot2)
